import UIKit

{% for type in types.implementing.StatefulView %}

protocol {{type.name|replace:"View",""}}ErrorViewController : class {
  var error: Error { set get }
}

enum {{type.name}}State {
  case empty
  case loading
  case failure(error: Error)
  case success(models: [{{type.name}}Model])
}

class {{type.name}}StateController: UIViewController {
  typealias ErrorViewController = {{type.name|replace:"View",""}}ErrorViewController & UIViewController

  private let emptyViewController: UIViewController
  private let loadingViewController: UIViewController
  private let failureViewController: ErrorViewController
  private let successController: {{type.name}}Controller

  init(emptyViewController: UIViewController,
       loadingViewController: UIViewController,
       failureViewController: ErrorViewController,
       successController: {{type.name}}Controller) {
    self.emptyViewController = emptyViewController
    self.loadingViewController = loadingViewController
    self.failureViewController = failureViewController
    self.successController = successController
    super.init(nibName: nil, bundle: nil)
  }

  required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }

  private func render(_ state: {{type.name}}State) {
    children.forEach {
      $0.removeFromParent()
    }
    let viewController: UIViewController
    switch state {
    case .empty:
      viewController = emptyViewController
    case .loading:
      viewController = loadingViewController
    case .failure(let error):
      viewController = failureViewController
      failureViewController.error = error
    case .success(let models):
      viewController = successController
      successController.reload(with: models)
    }
    viewController.willMove(toParent: self)
    addChild(viewController)
    viewController.view.frame = view.bounds
    view.addSubview(viewController.view)
    viewController.didMove(toParent: self)
  }
}
{% endfor %}
